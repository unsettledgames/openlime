<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>OpenLIME Source: ShaderRTI.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cerulean.css">

	<link type="text/css" rel="stylesheet" href="styles/openlime.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top navbar-inverse">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">OpenLIME</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="module-OpenLIME.html">OpenLIME</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="Annotation.html">Annotation</a></li><li><a href="BoundingBox.html">BoundingBox</a></li><li><a href="Cache.html">Cache</a></li><li><a href="Camera.html">Camera</a></li><li><a href="Canvas.html">Canvas</a></li><li><a href="Controller.html">Controller</a></li><li><a href="Controller2D.html">Controller2D</a></li><li><a href="ControllerPanZoom.html">ControllerPanZoom</a></li><li><a href="EditorSvgAnnotation.html">EditorSvgAnnotation</a></li><li><a href="FocusContext.html">FocusContext</a></li><li><a href="Layer.html">Layer</a></li><li><a href="LayerAnnotation.html">LayerAnnotation</a></li><li><a href="LayerBRDF.html">LayerBRDF</a></li><li><a href="LayerCombiner.html">LayerCombiner</a></li><li><a href="LayerImage.html">LayerImage</a></li><li><a href="LayerLens.html">LayerLens</a></li><li><a href="LayerRTI.html">LayerRTI</a></li><li><a href="LayerSvgAnnotation.html">LayerSvgAnnotation</a></li><li><a href="Layout.html">Layout</a></li><li><a href="module-OpenLIME-OpenLIME.html">OpenLIME~OpenLIME</a></li><li><a href="PointerManager.html">PointerManager</a></li><li><a href="Raster.html">Raster</a></li><li><a href="Shader.html">Shader</a></li><li><a href="ShaderBRDF.html">ShaderBRDF</a></li><li><a href="ShaderCombiner.html">ShaderCombiner</a></li><li><a href="ShaderRTI.html">ShaderRTI</a></li><li><a href="Skin.html">Skin</a></li><li><a href="Transform.html">Transform</a></li><li><a href="UIBasic.html">UIBasic</a></li><li><a href="UIDialog.html">UIDialog</a></li><li><a href="Viewer.html">Viewer</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="events.list.html" class="dropdown-toggle" data-toggle="dropdown">Events<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="Camera.html#event:update">Camera#event:update</a></li><li><a href="Canvas.html#event:ready">Canvas#event:ready</a></li><li><a href="Canvas.html#event:update">Canvas#event:update</a></li><li><a href="Canvas.html#event:updateSize">Canvas#event:updateSize</a></li><li><a href="Layer.html#event:ready">Layer#event:ready</a></li><li><a href="Layer.html#event:update">Layer#event:update</a></li><li><a href="Layout.html#event:ready">Layout#event:ready</a></li><li><a href="Layout.html#event:updateSize">Layout#event:updateSize</a></li><li><a href="UIDialog.html#event:closed">UIDialog#event:closed</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="tutorials.list.html" class="dropdown-toggle" data-toggle="dropdown">Howto<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="tutorial-getting-started.html">Getting started with OpenLIME</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="global.html#crudCallback">crudCallback</a></li><li><a href="global.html#simplify">simplify</a></li><li><a href="global.html#smooth">smooth</a></li><li><a href="global.html#smoothToPath">smoothToPath</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: ShaderRTI.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">import { Shader } from './Shader.js'

/**
 *  @param {object} options
 * *compose*: compose operation: add, subtract, multiply, etc.
 */

class ShaderRTI extends Shader {
	constructor(options) {
		super({});

		Object.assign(this, {
			modes: ['light', 'normals', 'diffuse', 'specular'],
			mode: 'normal',
			type:        ['ptm', 'hsh',  'sh', 'rbf', 'bln'],
			colorspaces: ['lrgb', 'rgb', 'mrgb', 'mycc'],

			nplanes: null,     //number of coefficient planes
			yccplanes: null,     //number of luminance planes for mycc color space
			njpegs: null,      //number of textures needed (ceil(nplanes/3))
			material: null,    //material parameters
			lights: null,      //light directions (needed for rbf interpolation)
			sigma: null,       //rbf interpolation parameter
			ndimensions: null, //PCA dimension space (for rbf and bln)

			scale: null,      //factor and bias are used to dequantize coefficient planes.
			bias: null,

			basis: null,       //PCA basis for rbf and bln
			lweights: null    //light direction dependent coefficients to be used with coefficient planes
		});
		Object.assign(this, options);

		if(this.relight)
			this.init(this.relight);

		this.setMode('light');
	}

	setMode(mode) {
		if(!(this.modes.includes(mode)))
			throw Error("Unknown mode: " + mode);
		this.mode = mode;

		if( mode != 'light') {
			this.lightWeights([ 0.612,  0.354, 0.707], 'base');
			this.lightWeights([-0.612,  0.354, 0.707], 'base1');
			this.lightWeights([     0, -0.707, 0.707], 'base2');
		}
		this.needsUpdate = true;
	}

	setLight(light) {
		if(!this.uniforms.light) 
			throw "Shader not initialized, wait on layer ready event for setLight."

		let x = light[0];
		let y = light[1];

		//map the square to the circle.
		let r = Math.sqrt(x*x + y*y);
		if(r > 1) {
			x /= r;
			y /= r;
		}
		let z = Math.sqrt(Math.max(0, 1 - x*x - y*y));
		light = [x, y, z];

		if(this.mode == 'light')
			this.lightWeights(light, 'base');
		this.setUniform('light', light);
	}
	setSpecularExp(value) {
		this.setUniform('specular_exp', value);
	}

	init(relight) {
		Object.assign(this, relight);
		if(this.colorspace == 'mycc')
			this.nplanes = this.yccplanes[0] + this.yccplanes[1] + this.yccplanes[2];
		else 
			this.yccplanes = [0, 0, 0];


		this.planes = [];
		this.njpegs = 0;
		while(this.njpegs*3 &lt; this.nplanes)
			this.njpegs++;

		for(let i = 0; i &lt; this.njpegs; i++)
			this.samplers.push({ id:i, name:'plane'+i, type:'vec3' });
		if(this.normals)
			this.samplers.push({id:this.njpegs, name:'normals', type:'vec3' });

		if(this.normals)
			this.samplers.push({ id:this.njpegs, name:'normals', type:'vec3'});

		this.material = this.materials[0];

		if(this.lights)
			this.lights + new Float32Array(this.lights);

		if(this.type == "rbf")
			this.ndimensions = this.lights.length/3;


		if(this.type == "bilinear") {
			this.ndimensions = this.resolution*this.resolution;
			this.type = "bln";
		}

		this.scale = this.material.scale;
		this.bias = this.material.bias;


		if(['mrgb', 'mycc'].includes(this.colorspace))
			this.loadBasis(this.basis);


		this.uniforms = {
			light: { type: 'vec3', needsUpdate: true, size: 3,              value: [0.0, 0.0, 1] },
			specular_exp: { type: 'float', needsUpdate: false, size: 1, value: 10 },
			bias:  { type: 'vec3', needsUpdate: true, size: this.nplanes/3, value: this.bias },
			scale: { type: 'vec3', needsUpdate: true, size: this.nplanes/3, value: this.scale },
			base:  { type: 'vec3', needsUpdate: true, size: this.nplanes },
			base1: { type: 'vec3', needsUpdate: false, size: this.nplanes },
			base2: { type: 'vec3', needsUpdate: false, size: this.nplanes }
		}

		this.lightWeights([0, 0, 1], 'base');
	}

	lightWeights(light, basename, time) {
		let value;
		switch(this.type) {
			case 'ptm': value = PTM.lightWeights(light); break;
			case 'hsh': value = HSH.lightWeights(light); break;
			case 'sh' : value = SH.lightWeights(light); break;
			case 'rbf': value = RBF.lightWeights(light, this); break;
			case 'bln': value = BLN.lightWeights(light, this); break;
		}
		this.setUniform(basename, value, time);
	}

	baseLightOffset(p, l, k) {
		return (p*this.ndimensions + l)*3 + k;
	}

	basePixelOffset(p, x, y, k) {
		return (p*this.resolution*this.resolution + (x + y*this.resolution))*3 + k;
	}

	loadBasis(data) {
		let tmp = new Uint8Array(data);
		this.basis = new Float32Array(data.length);

		let basis = new Float32Array(tmp.length);
		for(let plane = 0; plane &lt; this.nplanes+1; plane++) {
			for(let c = 0; c &lt; this.ndimensions; c++) {
				for(let k = 0; k &lt; 3; k++) {
					let o = this.baseLightOffset(plane, c, k);
					if(plane == 0)
						this.basis[o] = tmp[o]/255;
					else
						this.basis[o] = ((tmp[o] - 127)/this.material.range[plane-1]);
				}
			}
		}
	}

	fragShaderSrc(gl) {
		
		let basetype = 'vec3'; //(this.colorspace == 'mrgb' || this.colorspace == 'mycc')?'vec3':'float';
		let gl2 = !(gl instanceof WebGLRenderingContext);
		let str = `${gl2? '#version 300 es' : ''}

precision highp float; 
precision highp int; 

#define np1 ${this.nplanes + 1}

${gl2? 'in' : 'varying'} vec2 v_texcoord;
${gl2? 'out' : ''} vec4 color;

const mat3 T = mat3(8.1650e-01, 4.7140e-01, 4.7140e-01,
	-8.1650e-01, 4.7140e-01,  4.7140e-01,
	-1.6222e-08, -9.4281e-01, 4.7140e-01);

uniform vec3 light;
uniform float specular_exp;
uniform vec3 bias[np1];
uniform vec3 scale[np1];

uniform ${basetype} base[np1];
uniform ${basetype} base1[np1];
uniform ${basetype} base2[np1];
`;

		for(let n = 0; n &lt; this.njpegs; n++) 
			str += `
uniform sampler2D plane${n};
`;

		if(this.normals)
			str += `
uniform sampler2D normals;
`;

		if(this.colorspace == 'mycc')
			str +=
`

const int ny0 = ${this.yccplanes[0]};
const int ny1 = ${this.yccplanes[1]};
`

		switch(this.colorspace) {
			case 'rgb':  str +=  RGB.render(this.njpegs, gl2); break;
			case 'mrgb': str += MRGB.render(this.njpegs, gl2); break;
			case 'mycc': str += MYCC.render(this.njpegs, this.yccplanes[0], gl2); break;
		}

		str += `

void main(void) {

`;
		if(this.mode == 'light') {
			str += `
	color = render(base);
`;
		} else  {
			if(this.normals)
				str += `
	vec3 normal = (texture${gl2?'':'2D'}(normals, v_texcoord).zyx *2.0) - 1.0;
	normal.z = sqrt(1.0 - normal.x*normal.x - normal.y*normal.y);
`;
			else
				str += `
	vec3 normal;
	normal.x = dot(render(base ).xyz, vec3(1));
	normal.y = dot(render(base1).xyz, vec3(1));
	normal.z = dot(render(base2).xyz, vec3(1));
	normal = normalize(T * normal);
`; 
			switch(this.mode) {
			case 'normals':  str += `
	normal = (normal + 1.0)/2.0;
	color = vec4(0.0, normal.xy, 1);
`;
			break;

			case 'diffuse': str += `
	color = vec4(vec3(dot(light, normal)), 1);
`;
			break;

			case 'specular': 
			default: str += `
	float s = pow(dot(light, normal), specular_exp);
	//color = vec4(render(base).xyz*s, 1.0);
	color = vec4(s, s, s, 1.0);
`;
			break;
			}
		}

		str += `
	${gl2?'':'gl_FragColor = color;'}
}`;
		return str;
	}
}



class RGB {
	static render(njpegs, gl2) {
		let str = `
vec4 render(vec3 base[np1]) {
	vec4 rgb = vec4(0, 0, 0, 1);`;

		for(let j = 0; j &lt; njpegs; j++) {
			str += `
	{
		vec4 c = texture${gl2?'':'2D'}(plane${j}, v_texcoord);
		rgb.x += base[${j}].x*(c.x - bias[${j}].x)*scale[${j}].x;
		rgb.y += base[${j}].y*(c.y - bias[${j}].y)*scale[${j}].y;
		rgb.z += base[${j}].z*(c.z - bias[${j}].z)*scale[${j}].z;
	}
`;
		}
		str += `
	return rgb;
}
`;
		return str;
	}
}

class MRGB {
	static render(njpegs, gl2) {
		let str = `
vec4 render(vec3 base[np1]) {
	vec3 rgb = base[0];
	vec4 c;
	vec3 r;
`;
		for(let j = 0; j &lt; njpegs; j++) {
			str +=
`	c = texture${gl2?'':'2D'}(plane${j}, v_texcoord);
	r = (c.xyz - bias[${j}])* scale[${j}];

	rgb += base[${j}*3+1]*r.x;
	rgb += base[${j}*3+2]*r.y;
	rgb += base[${j}*3+3]*r.z;
`;
		}
		str += `
	return vec4(rgb, 1);
}
`;
		return str;
	}
}

class MYCC {

	static render(njpegs, ny1, gl2) {
		let str = `
vec3 toRgb(vec3 ycc) {
 	vec3 rgb;
	rgb.g = ycc.r + ycc.b/2.0;
	rgb.b = ycc.r - ycc.b/2.0 - ycc.g/2.0;
	rgb.r = rgb.b + ycc.g;
	return rgb;
}

vec4 render(vec3 base[np1]) {
	vec3 rgb = base[0];
	vec4 c;
	vec3 r;
`;
		for(let j = 0; j &lt; njpegs; j++) {
			str += `

	c = texture${gl2?'':'2D'}(plane${j}, v_texcoord);

	r = (c.xyz - bias[${j}])* scale[${j}];
`;

			if(j &lt; ny1) {
				str += `
	rgb.x += base[${j}*3+1].x*r.x;
	rgb.y += base[${j}*3+2].y*r.y;
	rgb.z += base[${j}*3+3].z*r.z;
`;
			} else {
				str += `
	rgb.x += base[${j}*3+1].x*r.x;
	rgb.x += base[${j}*3+2].x*r.y;
	rgb.x += base[${j}*3+3].x*r.z;
`;
			}
		}
		str += `	
	return vec4(toRgb(rgb), 1);
}
`;
		return str;
	}
}




/* PTM utility functions 
 */
class PTM {
	/* @param {Array} v expects light direction as [x, y, z]
	*/
	static lightWeights(v) {
		let b = [1.0, v[0], v[1], v[0]*v[0], v[0]*v[1], v[1]*v[1]];
		let base = new Float32Array(18);
		for(let i = 0; i &lt; 18; i++)
			base[3*i] = base[3*i+1] = base[3*i+2] = b[i];
		return base;
	}
}


/* HSH utility functions 
 */
class HSH {
	/* @param {Array} v expects light direction as [x, y, z]
	*/
	static lightWeights(v) {
		let PI = 3.1415;
		let phi = Math.atan2(v[1], v[0]);
		if (phi &lt; 0)
			phi = 2 * PI + phi;
		let theta = Math.min(Math.acos(v[2]), PI / 2 - 0.1);

		let cosP = Math.cos(phi);
		let cosT = Math.cos(theta);
		let cosT2 = cosT * cosT;

		let b = [
			1.0 / Math.sqrt(2 * PI),

			Math.sqrt(6 / PI) * (cosP * Math.sqrt(cosT-cosT2)),
			Math.sqrt(3 / (2 * PI)) * (-1 + 2*cosT),
			Math.sqrt(6 / PI) * (Math.sqrt(cosT - cosT2) * Math.sin(phi)),

			Math.sqrt(30 / PI) * (Math.cos(2 * phi) * (-cosT + cosT2)),
			Math.sqrt(30 / PI) * (cosP*(-1 + 2 * cosT) * Math.sqrt(cosT - cosT2)),
			Math.sqrt(5  / (2 * PI)) * (1 - 6 * cosT + 6 * cosT2),
			Math.sqrt(30 / PI) * ((-1 + 2 * cosT) * Math.sqrt(cosT - cosT2) * Math.sin(phi)),
			Math.sqrt(30 / PI) * ((-cosT + cosT2) * Math.sin(2*phi))
		];
		let base = new Float32Array(27);
		for(let i = 0; i &lt; 27; i++)
			base[3*i] = base[3*i+1] = base[3*i+2] = b[i];
		return base;
	}
}

class SH {
	/* @param {Array} v expects light direction as [x, y, z]
	*/
	static lightWeights(v) {
		let PI = 3.1415;
		let A = 0.5*Math.sqrt(3.0/PI);
		let B = 0.5*Math.sqrt(15/PI);
		let b = [
			0.5/Math.sqrt(PI),
			A*v[0],
			A*v[2],
			A*v[1],
			B*v[0]*v[1],
			B*v[0]*v[2],
			0.5*Math.sqrt(5/PI)*(3*v[2]*v[2] - 1),
			B*v[1]*v[2],
			0.5*B*(v[1]*v[1] - v[0]*v[0])
		];

		let base = new Float32Array(27);
		for(let i = 0; i &lt; 27; i++)
			base[3*i] = base[3*i+1] = base[3*i+2] = b[i];
		return base;
	}
}


class RBF {
	/* @param {Array} v expects light direction as [x, y, z]
	*/
	static lightWeights(lpos, shader) {

		let weights = RBF.rbf(lpos, shader);

		let np = shader.nplanes;
		let lweights = new Float32Array((np + 1) * 3);

		for(let p = 0; p &lt; np+1; p++) {
			for(let k = 0; k &lt; 3; k++) {
				for(let l = 0; l &lt; weights.length; l++) {
					let o = shader.baseLightOffset(p, weights[l][0], k);
					lweights[3*p + k] += weights[l][1]*shader.basis[o];
				}
			}
		}
		return lweights;
	}

	static rbf(lpos, shader) {
		let radius = 1/(shader.sigma*shader.sigma);
		let weights = new Array(shader.ndimensions);

		//compute rbf weights
		let totw = 0.0;
		for(let i = 0; i &lt; weights.length; i++) {
			let dx = shader.lights[i*3+0] - lpos[0];
			let dy = shader.lights[i*3+1] - lpos[1];
			let dz = shader.lights[i*3+2] - lpos[2];

			let d2 = dx*dx + dy*dy + dz*dz;
			let w = Math.exp(-radius * d2);

			weights[i] = [i, w];
			totw += w;
		}
		for(let i = 0; i &lt; weights.length; i++)
			weights[i][1] /= totw;


		//pick only most significant and renormalize
		let count = 0;
		totw = 0.0;
		for(let i = 0; i &lt; weights.length; i++) {
			if(weights[i][1] > 0.001) {
				weights[count++] =  weights[i];
				totw += weights[i][1];
			}
		}

		weights = weights.slice(0, count); 
		for(let i = 0; i &lt; weights.length; i++)
			weights[i][1] /= totw;

		return weights;
	}
}

class BLN {
	static lightWeights(lpos, shader) {
		let np = shader.nplanes;
		let s = Math.abs(lpos[0]) + Math.abs(lpos[1]) + Math.abs(lpos[2]);

		//rotate 45 deg.
		let x = (lpos[0] + lpos[1])/s;
		let y = (lpos[1] - lpos[0])/s;
		x = (x + 1.0)/2.0;
		y = (y + 1.0)/2.0;
		x = x*(shader.resolution - 1.0);
		y = y*(shader.resolution - 1.0);

		let sx = Math.min(shader.resolution-2, Math.max(0, Math.floor(x)));
		let sy = Math.min(shader.resolution-2, Math.max(0, Math.floor(y)));
		let dx = x - sx;
		let dy = y - sy;

		//bilinear interpolation coefficients.
		let s00 = (1 - dx)*(1 - dy);
		let s10 =      dx *(1 - dy);
		let s01 = (1 - dx)* dy;
		let s11 =      dx * dy;

		let lweights = new Float32Array((np + 1) * 3);

		//TODO optimize away basePixel

		for(let p = 0; p &lt; np+1; p++) {
			for(let k = 0; k &lt; 3; k++) {
				let o00 = shader.basePixelOffset(p, sx, sy, k);
				let o10 = shader.basePixelOffset(p, sx+1, sy, k);
				let o01 = shader.basePixelOffset(p, sx, sy+1, k);
				let o11 = shader.basePixelOffset(p, sx+1, sy+1, k);

				lweights[3*p + k] = 
					s00*shader.basis[o00] + 
					s10*shader.basis[o10] +
					s01*shader.basis[o01] +
					s11*shader.basis[o11];

			}
		}
		return lweights;
	}
}


export { ShaderRTI }

</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>

	<div class='jsdoc-message'>ISTI - CNR & CRS4 - ViC</div>


	<span class="copyright">
	DocStrap Copyright Â© 2012-2015 The contributors to the JSDoc3 and DocStrap projects.
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a>
	
		on Thu Apr 14th 2022
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
